#! /usr/bin/env bash

# libbash - a collection of useful functions for your Bash scripts
#
# Copyright (C) Georg Lauterbach
# GitHub: https://github.com/georglauterbach/libbash

# shellcheck disable=SC2329

# ### The Start of `libbash`
#
# This function calls the initialization routines for `libbash`
# in proper order.
function __libbash__main() {
  if [[ ${BASH_VERSINFO[0]} -lt 5 ]]; then
    __libbash__show_error "libbash only supports Bash version >= 5.0.0"
    return 1
  fi

  # if SCRIPT is already set, save it so we can restore it later
  [[ -v SCRIPT ]] && __LIBBASH_SCRIPT_TMP=${SCRIPT}
  SCRIPT='libbash init'
  LOG_LEVEL=${LOG_LEVEL:-info}

  LIBBASH_DIRECTORY="$(realpath -eL "$(dirname "${BASH_SOURCE[0]}")")"
  LIBBASH_LOADED_MODULES=()

  # ! export all variables here first, even if not
  # ! all modules are sourced to satisfy shellcheck
  # ! in applications that use `libbash`
  export SCRIPT LOG_LEVEL CRI
  export LIBBASH_DIRECTORY LIBBASH_LOADED_MODULES

  local MODULE MODULE_LOAD_FUNCTION
  for MODULE in "${@}"; do
    MODULE_LOAD_FUNCTION="__libbash__load_module_${MODULE}"

    if [[ ${LIBBASH_LOADED_MODULES[*]} =~ ${MODULE} ]]; then
      __libbash__exit_with_error_and_callstack "module '${MODULE}' loaded more than once" 2
    fi

    if [[ $(type -t "${MODULE_LOAD_FUNCTION}") != 'function' ]]; then
      __libbash__exit_with_error_and_callstack "module '${MODULE}' does not exist" 3
    fi


    if ! "${MODULE_LOAD_FUNCTION}"; then
      __libbash__exit_with_error_and_callstack "module '${MODULE}' failed to load" 4
    fi

    unset "${MODULE_LOAD_FUNCTION}"
    LIBBASH_LOADED_MODULES+=("${MODULE}")
  done

  # ! this has to come last
  if [[ ${LIBBASH_LOADED_MODULES[*]} != *log* ]]; then
    function log() {
      if [[ ${1:-} != 'error' ]]; then
        __libbash__exit_with_error_and_callstack \
          "log module not loaded but 'log' called with log level other than 'error' (arguments: ${*})"
        return 1
      fi

      shift 1
      __libbash__show_error "${*}"
    } ; export -f log
    return 0
  fi

  export LIBBASH_VERSION=0.9.0
  log 'trace' "Finished 'libbash ${LIBBASH_VERSION}' initialization"
}

if [[ ! -v LIBBASH__IS_LOADED ]]; then
  # ### Show an Error
  #
  # Indicates an error has happened in `libbash`. Used to display
  # errors even when the log module is not (or has not yet been)
  # loaded.
  #
  # #### Attention
  #
  # Underscored functions are not unset at the end of the sourcing
  # process, but they should only be used by `libbash` modules, not
  # by applications / other libraries using `libbash`.
  function __libbash__show_error() {
    printf "%s \e[91mERROR\e[0m %s: %s\n" \
      "$(date +"%Y-%m-%dT%H:%M:%S.%6N%:z" || :)" "${SCRIPT:-$(basename "${0}")}" "${*}" >&2
  }
  export -f __libbash__show_error
  readonly -f __libbash__show_error

  # ### Exit With Conditions
  #
  # This function will exit when not running interactively or when
  # 'LIBBASH_EXIT_IN_INTERACTIVE_MODE' is set to '1'.
  #
  # #### Attention
  #
  # Underscored functions are not unset at the end of the sourcing
  # process, but they should only be used by `libbash` modules, not
  # by applications / other libraries using `libbash`.
  function __libbash__exit_checked() {
    local CODE=${1:-1}
    if [[ ${-} != *i* ]] \
    || [[ ${LIBBASH_EXIT_IN_INTERACTIVE_MODE:-0} -eq 1 ]] \
    || [[ ${*} == *--force* ]]; then
      if [[ ${CODE} =~ ^[0-9]$ ]]; then
        exit "${CODE}"
      else
        log 'error' "Supplied non-number code ('${CODE}') to __libbash__exit_checked"
        exit 1
      fi
    else
      if [[ ${CODE} =~ ^[0-9]$ ]]; then
        return "${CODE}"
      else
        log 'error' "Supplied non-number code ('${CODE}') to __libbash__exit_checked"
        return 1
      fi
    fi
  }
  export -f __libbash__exit_checked
  readonly -f __libbash__exit_checked

  # ### Provides Call Stack Information
  #
  # This function prints the call stack to identify where an error
  # originated.
  #
  # This function will only print a call stack if the stack is
  # deeper than 2, because otherwise the error did not originate
  # in a function but at global scope.
  function __libbash__show_call_stack() {
    local STACK_DEPTH CUTOFF=1
    [[ ${*} == *--internal* ]] && CUTOFF=2
    [[ ${#FUNCNAME[@]} -gt ${CUTOFF} ]] || return 0

    STACK_DEPTH=$(( ${#FUNCNAME[@]} - CUTOFF ))

    printf '\ncall stack (most recent call first):\n' >&2
    for FUNCTION in "${FUNCNAME[@]:${CUTOFF}:${STACK_DEPTH}}"; do
      printf "  %s\n" "${FUNCTION}" >&2
    done

    printf '\n' >&2
  }
  export -f __libbash__show_call_stack
  readonly -f __libbash__show_call_stack

  # ### Show an Error and Exit
  #
  # Display
  function __libbash__exit_with_error_and_callstack() {
    __libbash__show_error "${1:-Error message not supplied (this is a bug in libbash)}"
    __libbash__show_call_stack --internal
    __libbash__exit_checked "${2:-1}"
  }
  export -f __libbash__exit_with_error_and_callstack
  readonly -f __libbash__exit_with_error_and_callstack

  # ### Provide Debug Information
  #
  # Shows some debug information that `libbash` has collected.
  function libbash__debug() {
    if [[ ! -v __LIBBASH__IS_LOADED_LOG ]]; then
      __libbash__exit_with_error_and_callstack "Debug functionality requires the log module to be loaded and log level set to 'debug' or 'trace'"
      return 1
    fi

    log 'debug' "Showing 'libbash' debug information"
    log 'debug' "  -> version: ${LIBBASH_VERSION}"
    log 'debug' "  -> Loaded modules: ${LIBBASH_LOADED_MODULES[*]}"
  }
  export -f libbash__debug

  export LIBBASH_EXIT_IN_INTERACTIVE_MODE=${LIBBASH_EXIT_IN_INTERACTIVE_MODE:-0}
  export LIBBASH__IS_LOADED=1
  readonly LIBBASH__IS_LOADED
fi # if ! ${LIBBASH__IS_LOADED:-false}

# Load the 'cri' module
function __libbash__load_module_cri() {
  # ### Checks Whether Docker or Podman is Installed
  #
  # Checks whether `docker` or `podman` is in `${PATH}` and
  # sets the `CRI` variable accordingly. Docker is chosen
  # first if both Docker and Podman are installed.
  function setup_container_runtime() {
    command -v 'docker' &>/dev/null && export CRI='docker' && return 0
    command -v 'podman' &>/dev/null && export CRI='podman' && return 0

    log 'error' \
      'Could not identify Container Runtime.' \
      "Is 'docker' or 'podman' in \${PATH}?"
    return 1
  } ; export -f setup_container_runtime
}

# Load the 'log' module
function __libbash__load_module_log() {
  export LIBBASH__LOG_COLOR_RESET='\e[0m'
  export LIBBASH__LOG_COLOR_TRACE='\e[92m'
  export LIBBASH__LOG_COLOR_DEBUG='\e[36m'
  export LIBBASH__LOG_COLOR_INFO='\e[34m'
  export LIBBASH__LOG_COLOR_WARN='\e[93m'
  export LIBBASH__LOG_COLOR_ERROR='\e[91m'

  if [[ ! -v __LIBBASH__IS_LOADED_LOG ]]; then
    export __LIBBASH__IS_LOADED_LOG=1
    readonly __LIBBASH__IS_LOADED_LOG
  fi

  # ### The Logging Functions
  #
  # `log` uses five different log levels and behaves as you would
  # expect from a log function: you provide the log level as the
  # first argument and the message in the consecutive ones. The
  # default log level is 'info'. The global log level is defined
  # in the
  #
  # #### Log Level
  #
  # The provided log level, as well as the environment variable
  # `LOG_LEVEL`, Can be one of
  #
  #   meaning - what to log
  #   -------------------------------------------------
  #   trace   - log trace information
  #   debug   - log debug information
  #   info    - log informational output
  #   warn    - log warnings
  #   error   - log critical errors and aborts
  #
  # where a higher level includes the level below. The
  # default log level is 'info' (2).
  #
  # #### Return Codes
  #
  # This function is infallible. Hence, it always returns with
  # return code 0, even when issues appeared.
  #
  # #### Arguments
  #
  # $1 :: log level
  # $2 :: message (strictly speaking optional, no default / empty string)
  function log() {
    function __log_generic() {
      local LEVEL=${1:?libbash bug: log level message format must be provided to __log_generic}
      local COLOR="LIBBASH__LOG_COLOR_${LEVEL^^}"
      shift 1

      # shellcheck disable=SC2059
      printf "%s ${!COLOR}%-5s${LIBBASH__LOG_COLOR_RESET} %s: %s\n" \
        "$(date +"%Y-%m-%dT%H:%M:%S.%6N%:z" || :)" "${LEVEL^^}" "${SCRIPT:-$(basename "${0}")}" "${*}"
    }

    if [[ -z ${1+set} ]]; then
      log 'warn' "'log' called without log level"
      __libbash__show_call_stack
      return 0
    elif [[ ! ${1} =~ ^(error|warn|info|debug|trace)$ ]]; then
      log 'warn' "'log' called with unknown log level (use 'error', 'warn', 'info', 'debug', or 'trace')"
      __libbash__show_call_stack
      return 0
    elif [[ -z ${2+set} ]]; then
      log 'warn' "'log' called without message"
      __libbash__show_call_stack
      return 0
    fi

    local MESSAGE_LOG_LEVEL="${1}"
    shift 1

    # ! scoping of dictionaries beyond `source` / in the global namespace is
    # ! even more horrendous that normal scoping in Bash - hence, we avoid it
    declare -A LOG_LEVEL_MAPPING=( ["error"]="0" ["warn"]="1" ["info"]="2" ["debug"]="3" ["trace"]="4" )

    if [[ -z ${LOG_LEVEL_MAPPING[${LOG_LEVEL:=info}]:-} ]]; then
      local OLD_LOG_LEVEL=${LOG_LEVEL}
      export LOG_LEVEL='debug'
      log 'warn' "Log level '${OLD_LOG_LEVEL}' unknown - resetting to log level '${LOG_LEVEL}'"
    fi

    [[ ${LOG_LEVEL_MAPPING[${LOG_LEVEL}]} -lt ${LOG_LEVEL_MAPPING[${MESSAGE_LOG_LEVEL}]} ]] && return 0

    if [[ ${LOG_LEVEL_MAPPING[${MESSAGE_LOG_LEVEL}]} -lt 2 ]]; then
      __log_generic "${MESSAGE_LOG_LEVEL}" "${*}" >&2
    else
      __log_generic "${MESSAGE_LOG_LEVEL}" "${*}"
    fi

    return 0
  } ; export -f log
}

# Load the 'errors' module
function __libbash__load_module_errors() {
  # cSpell: ignore gsub

  # Call `log_unexpected_error` with additional information
  # when the ERR trap is triggered.
  set -E -o pipefail
  shopt -s inherit_errexit
  trap 'log_unexpected_error "${FUNCNAME[0]:-}" "${BASH_COMMAND:-}" "${LINENO:-}" "${?:-}"' ERR

  # ### Remove Newlines from a String
  #
  # This function removes newlines from a given string,
  # replacing them with " ".
  #
  # #### Arguments
  #
  # $1 :: The string to escape (optional, default=unknown)
  #
  # #### Return Codes
  #
  # This function is infallible. Hence, it always returns with
  # return code 0.
  function remove_newlines() {
    local STRING=${1:-unknown}
    echo "${STRING//$'\n'/ }"
  } ; export -f remove_newlines

  # ### Expand a String
  #
  # This function expands a given string
  #
  # #### Arguments
  #
  # $1 :: The string to expand (optional, default=unknown)
  #
  # #### Attention
  #
  # This function uses `eval` to escape the string in the end.
  # While considerable effort has been put into proper escaping,
  # no one can guarantee that all pitfalls and escape hatches
  # have been eliminated that could lead to arbitrary code execution
  # with the `eval` at the end.
  #
  # Of special importance is the replacement '//\$\(/\\$\(', which
  # replaces all '$(' with '\$('.
  #
  # #### References
  #
  # StackOverflow
  #   - https://stackoverflow.com/a/20316582
  function apply_shell_expansion() {
    local DELIMITER="__apply_shell_expansion_delimiter__"
    local STRING_TO_ESCAPE=${1:-unknown}
    STRING_TO_ESCAPE=$(remove_newlines "${STRING_TO_ESCAPE}")
    STRING_TO_ESCAPE=${STRING_TO_ESCAPE//\$\(/\\$\(}

    eval "cat <<${DELIMITER}"$'\n'"${STRING_TO_ESCAPE}"$'\n'"${DELIMITER}"
  } ; export -f apply_shell_expansion

  # ### Log the Error Event
  #
  # This function is called when an unhandled error signal is thrown.
  # It prints information about the error (where it originated, etc.)
  # and also calls `__libbash__show_call_stack` to possibly print a
  # call stack if `__libbash__show_call_stack` deems it useful.
  #
  # #### Explanations
  #
  # The code below has to be used in conjunction with the `ERR` trap
  # above. The trap uses special variable that Bash sets to show the
  # user what happened.
  #
  # Furthermore, the `eval echo "${2:-unknown}"` expands all variables
  # in `${2}` (which contains the value of `${BASH_COMMAND}`, i.e. the command
  # that was executed). This is neat because the user can see the expanded
  # version of the command too.
  #
  # #### Attention
  #
  # Underscored functions are not unset at the end of the sourcing
  # process, but they should only be used by `libbash` modules, not
  # by applications / other libraries using `libbash`.
  #
  # Please also not the "Attention" section of `apply_shell_expansion`.
  #
  # #### Arguments
  #
  # $1 :: Name of the function the error happened in
  # $2 :: The command that caused the error
  # $3 :: The line number in which $2 was executed
  # $4 :: The return code of $2
  function log_unexpected_error() {
    # shellcheck disable=SC2155
    local MESSAGE="unexpected error occurred:
    script:     ${SCRIPT:-"${0}"}
    function:   ${1:-prompt or outside of function}
    command:
      plain:    $(remove_newlines "${2:-unknown}")
      expanded: $(apply_shell_expansion "${2:-unknown}")
    line:       ${3:-unknown}
    exit code:  ${4:-unknown}"

    __libbash__show_error "${MESSAGE}"
    __libbash__show_call_stack --internal
    return 0
  } ; export -f log_unexpected_error
}

# Load the 'utils' module
function __libbash__load_module_utils() {
  # cSpell: ignore mawk

  # ### Split a String with a Delimiter Into an Array
  #
  # Splitting a string into an array can be done in various ways.
  # The approach taken below is based on [1] but avoids 'awk'
  # because 'awk' is assumed to be 'gawk'. Sometimes, 'awk' is
  # something else ('mawk'), though, and this is not immediately
  # apparent and hence, error-prone.
  #
  # [1]: StackOverflow, https://stackoverflow.com/a/45201229
  #
  # #### Arguments
  #
  # $1 :: array name (this array is created)
  # $2 :: string to split
  # $3 :: delimiter (optional, default=:)
  #
  # #### Attention
  #
  # Backslash (`\`) does not work as a delimiter because the escaping logic
  # is simple and just removes backslashes.
  function split_into_array() {
    local ARRAY_NAME=${1:?array name is required}
    local STRING_TO_SPLIT=${2:?string to split is required}
    local DELIMITER=${3:-':'}
    local UNESCAPED_DELIMITER=${DELIMITER//\\/}

    STRING_TO_SPLIT=${STRING_TO_SPLIT#"${UNESCAPED_DELIMITER}"} # remove prefix
    STRING_TO_SPLIT=${STRING_TO_SPLIT%"${UNESCAPED_DELIMITER}"} # remove suffix

    readarray -t -d '' "${ARRAY_NAME}" \
      < <(printf '%s' "${STRING_TO_SPLIT}" | sed "s|${DELIMITER}|\x0|g")
  } ; export -f split_into_array

  # ### Check If a Line Is a Comment or Blank
  #
  # Checks if the provided first argument starts with
  # a comment or whether the line is blank.
  #
  # #### Arguments
  #
  # $1 :: line to be checked
  # $2 :: comment symbol (optional, default=#)
  function line_is_comment_or_blank() {
    local COMMENT_SYMBOL
    COMMENT_SYMBOL=${2:-#}
    grep -qE "^\s*$|^\s*${COMMENT_SYMBOL}" <<< "${1:-}"
  } ; export -f line_is_comment_or_blank

  # ### Escape All But Backslashes
  #
  # Takes a string and an escape character and
  # puts backslashes in front. Does not accept
  # backslashes as escape character. The escape
  # character must be a single character.
  #
  # #### Arguments
  #
  # $1 :: string to be escaped
  # $2 :: character that must be escaped
  function escape() {
    [[ ${2} =~ .*\\.* ]] && {
      log 'error' \
        "Escape character is not allowed to be or contain a backslash"\
        "(use 'escape_backslash')"
      return 1
    }

    parameter_is_not_empty "${1}" || {
      log 'error' 'No string to be escaped provided'
      return 1
    }

    parameter_is_not_empty "${2}" || {
      log 'error' 'No escape character(s) provided'
      return 1
    }

    [[ ${#2} -ge 2 ]] && {
      log 'error' 'More than two parameters provided'
      return 1
    }

    printf '%s' "${1//${2}/\\${2}}"
  } ; export -f escape

  # ### Escape Backslashes Only
  #
  # Takes a string and puts s backslash more
  # in front of an already present backslash.
  #
  # #### Arguments
  #
  # $1 :: string to be escaped
  function escape_backslash() {
    # shellcheck disable=SC1003
    printf '%s' "${1//'\'/'\\'}"
  } ; export -f escape_backslash

  # ### Exit Without Error
  #
  # Just a wrapper around `exit 0`.
  function exit_success() { exit 0 ; } ; export -f exit_success

  # ### Exit With Error
  #
  # Just a wrapper around `exit 1`. Another exit
  # code can be supplied as well.
  #
  # #### Arguments
  #
  # $1 :: exit code (optional, default=1)
  # $2 :: message (optional, default='' (no output is printed))
  function exit_failure() {
    local CODE=${1:-1}
    shift 1

    if [[ ! ${CODE} =~ ^[0-9]+$ ]]; then
      log 'error' "'exit_failure' was called with non-number exit code"
      __libbash__show_call_stack
      exit 1
    fi

    if [[ ${CODE} -eq 0 ]] || [[ ${CODE} -ge 127 ]]; then
      log 'error' "'exit_failure' was called with exit code 0 or >127"
      __libbash__show_call_stack
      exit 1
    fi

    parameter_is_not_empty "${1:-}" && log 'error' "${1}"
    exit "${CODE}"
  } ; export -f exit_failure

  # ### Exit Without Error
  #
  # Just a wrapper around `return 0`. This should only be
  # used at the very end of a function is it relies on Bash
  # settings the return code of the last command as the exit
  # code of the function.
  function return_success() { return 0 ; } ; export -f return_success

  # ### Exit With Error
  #
  # Just a wrapper around `return 1`. This should only be
  # used at the very end of a function is it relies on Bash
  # setting the return code of the last command as the exit
  # code of the function.
  #
  # #### Arguments
  #
  # $1 :: message (optional, default='')
  function return_failure() {
    if [[ ! ${1:-1} =~ ^[0-9]+$ ]]; then
      log 'error' "'return_failure' was called with non-number exit code"
      __libbash__show_call_stack
      exit 1
    fi

    if [[ ${1:-1} -eq 0 ]] || [[ ${1:-1} -ge 128 ]]; then
      log 'error' "'return_failure' was called with exit code 0 or >127"
      __libbash__show_call_stack
      exit 1
    fi

    parameter_is_not_empty "${*}" && log 'error' "${*}"
    return "${1:-1}"
  } ; export -f  return_failure

  # ### Exit with Error and Show the Callstack
  #
  # This function exits with exit code 1 but also
  # prints information about the call stack. Another
  # exit code can be supplied as well.
  #
  # #### Arguments
  #
  # Same as `exit_failure`.
  function exit_failure_show_callstack() {
    parameter_is_not_empty "${2:-}" && log 'error' "${2}"
    __libbash__show_call_stack
    exit_failure "${1:-}"
  } ; export -f exit_failure_show_callstack

  # ### Check if Variable is Set
  #
  # This function checks if an environment variable is set.
  #
  # #### Arguments
  #
  # $1 :: the variable's name
  function var_is_set() {
    [[ -v ${1:-__UNSET__} ]]
  } ; export -f var_is_set

  # ### Check if Variable is Set and Not Empty
  #
  # This function checks if an environment variable is set
  # and not empty.
  #
  # #### Arguments
  #
  # $1 :: the variable's name
  function var_is_set_and_not_empty() {
    var_is_set "${1}" && [[ -n ${!1:-} ]]
  } ; export -f var_is_set_and_not_empty

  # ### Tell Whether a Parameter to a Function is Set and Not Empty
  #
  # This function returns true if the variable given in $1
  # is not null and not empty.
  #
  # #### Arguments
  #
  # $1 :: the parameter you want to check
  #
  # #### Example
  #
  # ```bash
  # function my_echo() {
  #   parameter_is_not_empty "${1}"
  #   echo "${1}"
  # }
  # ```
  function parameter_is_not_empty() {
    [[ -n ${1:-} ]]
  } ; export -f parameter_is_not_empty

  # ### Ask a Question
  #
  # This function states a question and returns the result
  # in a variable name given to this function.
  #
  # #### Arguments
  #
  # $1 :: question
  # $2 :: variable name to store the result in
  function ask_question() {
    parameter_is_not_empty "${1}" || {
      log 'error' 'No question provided'
      return 1
    }

    parameter_is_not_empty "${2}" || {
      log 'error' 'No variable to store result in provided'
      return 1
    }

    local QUESTION=${1}
    local -n VARIABLE_TO_STORE_ANSWER_IN=${2}

    # shellcheck disable=SC2034
    read -r -p "${QUESTION} " VARIABLE_TO_STORE_ANSWER_IN
  } ; export -f ask_question

  # ### Ask a Question - Special Case
  #
  # This function is for the special case where the question
  # is a yes-or-no question (binary). It will state the question
  # and it can be given a default answer. It will return true or
  # false depending on the default and the user input.
  #
  # #### Arguments
  #
  # $1 :: question
  # $2 :: default (optional, default=no)
  function ask_yes_no_question() {
    parameter_is_not_empty "${1}" || {
      log 'error' 'No question provided'
      return 1
    }

    local ANSWER DEFAULT_STRING
    local DEFAULT=${2:-no} YES_REGEXP='^(y|yes)$'
    DEFAULT=${DEFAULT,,}

    if [[ ${DEFAULT} =~ ${YES_REGEXP} ]]; then
      DEFAULT_STRING=' [Y/n]'
    else
      DEFAULT_STRING=' [y/N]'
    fi

    ask_question "${1}${DEFAULT_STRING}" ANSWER

    if [[ ${DEFAULT} =~ ${YES_REGEXP} ]] && [[ -z ${ANSWER} ]]; then
      return 0
    elif [[ ${DEFAULT} =~ ^(n|N|no|No)$ ]] && [[ -z ${ANSWER} ]]; then
      return 1
    fi

    [[ ${ANSWER,,} =~ ${YES_REGEXP} ]]
  } ; export -f ask_yes_no_question

  # ### Is a Program in ${PATH}?
  #
  # This function returns with exit code 0 (success) if
  # the argument given is in ${PATH}, otherwise exit code
  # 1 (failure) is returned.
  #
  # #### Arguments
  #
  # $1 :: executable to check
  function is_in_path() {
    parameter_is_not_empty "${1}" || {
      log 'error' 'No name for an executable provided'
      return 1
    }

    command -v "${1}" &>/dev/null
  } ; export -f is_in_path

  # ### Is a Program Not in ${PATH}?
  #
  # This function returns with exit code 1 (failure) if
  # the argument given is not in ${PATH}, otherwise exit
  # code 0 (success) is returned.
  #
  # #### Arguments
  #
  # $1 :: executable to check
  function is_not_in_path() {
    ! is_in_path "${1}"
  } ; export -f is_not_in_path

  # ### Check Whether a Directory is Empty
  #
  # This function checks whether a directory
  # contains files or other directories, and
  # returns false if so.
  #
  # #### Arguments
  #
  # $1 :: directory to check
  function dir_is_empty() {
    parameter_is_not_empty "${1}" || {
      log 'error' 'No name for an executable provided'
      return 1
    }

    [[ -n $(find "${1}" -maxdepth 0 -empty) ]]
  } ; export -f dir_is_empty

  # ### Check Whether a Directory is Not Empty
  #
  # This function checks whether a directory
  # contains files or other directories, and
  # returns true if so.
  #
  # #### Arguments
  #
  # $1 :: directory to check
  function dir_is_not_empty() {
    ! dir_is_empty "${1}"
  } ; export -f dir_is_not_empty

  # ### Checks Whether a Variable Evaluates to True
  #
  # This function checks, when expanding the string
  # and making it lowercase, whether this string
  # is "true", "yes" or "y".
  #
  # #### Arguments
  #
  # $1 :: name of environment variable to check
  function value_is_true() {
    declare -n __VAR=${1}
    [[ ${__VAR,,} =~ ^(true|y(es)?)$ ]]
  } ; export -f value_is_true
}

# Independently of whether we finished initialization successfully or not,
# we want to clean up. This function performs exactly this functionality.
function __libbash__post_init() {
  unset __libbash__main
  unset __libbash__post_init

  if [[ -v __LIBBASH_SCRIPT_TMP ]]; then
    SCRIPT=${__LIBBASH_SCRIPT_TMP}
    unset __LIBBASH_SCRIPT_TMP
  else
    SCRIPT='prompt or outside of function'
  fi
}

if __libbash__main "${@}"; then
  __libbash__post_init
else
  __LIBBASH__RETURN_CODE_INIT=${?}
  __libbash__post_init
  ( exit "${__LIBBASH__RETURN_CODE_INIT}" ; )
fi
