#! /bin/bash

# version       0.1.2
# executed by   scripts that use `libbash`
# task          perform library initialization

SCRIPT='libbash initialization'
LIBBASH_LOAD_FILE_LOCATION="${BASH_SOURCE[0]}"

# ### Show an Error
#
# Indicates an error has happend in `libbash`.
#
# #### Special
# 
# Underscored functions are not unset at the end of the sourcing
# process, but they should only be used by `libbash` modules, not
# by applications / other libraries using `libbash`.
function __libbash_show_error
{
  printf "\e[0m[  \e[91mERROR\e[0m  ] %30s | \e[91m%s\e[0m\n" \
    "${SCRIPT:-${0}}" "${*}" >&2
}

# ### Show an Error and Exit
#
# Indicates an error has happend in `libbash`. Exits with exit code
# 1 afterwards.
#
# #### Special
# 
# Underscored functions are not unset at the end of the sourcing
# process, but they should only be used by `libbash` modules, not
# by applications / other libraries using `libbash`.
function __libbash_show_error_and_exit
{
  __libbash_show_error "${*}"
  exit 1
}

# ### Perform Basic `libbash` Initialization
#
# Mostly sets corrects environment variables.
function basic_setup
{
  # ! export all variables here first, even if not
  # ! all modules are sourced to satisfy shellcheck
  # ! in applications that use `libbash`
  export CRI LOG_LEVEL LIBBASH_DIRECTORY SCRIPT

  LOG_LEVEL=${LOG_LEVEL:-inf}
  LIBBASH_DIRECTORY="$(dirname "${LIBBASH_LOAD_FILE_LOCATION}")"
}

# ### Load a `libbash` Module
#
# Checks if the given modules is present (exits unsuccessfully)
# otherwise. Then loads the module by sourcing it.
function load_module
{
  [[ -z ${1+set} ]] && __libbash_show_error_and_exit "no module provided"

  local MODULE_PATH
  MODULE_PATH="${LIBBASH_DIRECTORY}/src/${1}.sh"

  if [[ -e "${MODULE_PATH}" ]]
  then
    # shellcheck source=/dev/null
    source "${MODULE_PATH}"
  else
    __libbash_show_error_and_exit "module '${1:-}' not found"
  fi
}

# ### Go Through Arguments
#
# Iterates through arguments and calls `load_module` to
# load the corresponding module.
function source_files
{
  local MODULE
  for MODULE in "${@}"
  do
    [[ ${*} =~ ${MODULE} ]] && load_module "${MODULE}"
  done

  unset load_module MODULES
}

# ### Provide Debug Information
#
# Shows some debug information that `libbash` has collected.
function debug_libbash
{
  notify 'deb' "Showing 'libbash' debug information"
  notify 'deb' "Call / source stack:"
  for (( INDEX=${#BASH_SOURCE[@]} - 1 ; INDEX>1 ; INDEX-- ))
  do
    printf "%45s%s\n" '' "${BASH_SOURCE[INDEX]}"
  done
}

# ### Fallback `notify`
#
# If the `log` module was not sourced, provide a fallback
# `notify` implementation, but onyl for `err` messages.
function setup_default_notify_error
{
  function notify
  {
    if [[ ${1:-} != 'err' ]]
    then
      __libbash_show_error                                  \
        "log module was not loaded but 'notify' was called" \
        "with log level not 'err'"
      return 1
    fi

    __libbash_show_error "${@}"
  }
  export -f notify
}

function main
# ### The Start of `libbash`
#
# This function calls the initialization routines for `libbash`
# in proper order. 
function libbash_main
{
  basic_setup
  source_files "${@}"

  if [[ ! $(type -t notify) == 'function' ]]
  then
    setup_default_notify_error
    return 0
  fi

  notify 'tra' "Finished 'libbash' initialization"
}

main "${@}"
unset LIBBASH_LOAD_FILE_LOCATION
unset basic_setup load_module source_files setup_default_notify_error main
